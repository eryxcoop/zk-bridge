# Documentation for ZK Bridge - Milestone 4

In this documentation we will describe the technical details of the validators needed to implement the minting transaction of our bridge. We will first describe the transaction and then walk through the validators needed for this to work.

NOTE: Additional HTML documentation can be generated by running the following command:

```bash
aiken docs
```

This additional HTML documentation is useful because it contains descriptions for each relevant struct and function.

## Transactions

### Minting transaction (`minting_tx`)

This transaction is executed on the destination chain of the bridge. In this transaction we must present a proof that verifies that a locking transaction took place on the source chain of the bridge, and mint equivalent tokens to those of the locking transaction.

Since the scope of the project does not include choosing a destination chain for the bridge, in this milestone we implemented the validators required to build a bridge between Cardano and an isomorphic chain. The validators are written in Aiken, a language supported by Cardano and other isomorphic chains.

In order to mint tokens on the destination chain of the bridge, we need to:

 1. Present a locking transaction along with a proof that it is valid on the source chain.
 2. Verify that tokens have not already been minted in the destination chain using the same locking transaction.
 3. Present a ZK proof that the locking transaction actually existed.

For step 2, we reused code from the previous milestone validator: `tx_updater`. Recall that in the unlocking validator of milestone 3 we also needed to verify that the presented burning transaction had not been used previously. We had to make some changes to that validator in order to make it work for the minting transaction, this can be seen in the `Transactions Updater validator` section of this document.

Step 3 is the most difficult challenge of the bridge, and it is where we decided to leverage Mithril to solve the challenge of proving the inclusion of a transaction in Cardano. Throughout [the document delivered in milestone 2 of our project](https://github.com/eryxcoop/zk-bridge/blob/main/milestone_2_deliverables/zk_bridge.pdf) (particularly in sections 6.2 and 7.2), we explain how the stake distribution and minting validators achieve this.

In summary, the stake distribution validator is used to maintain a UTXO that contains Cardano’s stake distribution. This UTXO will be used as a reference input in the minting validator, where we also receive a certificate proving that a locking transaction was executed on the sender chain, along with a proof that the certificate is valid for the provided stake distribution.

### Stake distribution transaction (`stake_distribution_tx`)

This transaction is executed in the destination chain of the bridge. Its purpose is to add a new Mithril certificate for our chain directly from Mithril's certificate chain. Specifically, this certificate must sign an entity type of `MithrilStakeDistribution`, which corresponds to the first Mithril certficate signed for a given epoch. Refer to [Certificate chain design](https://mithril.network/doc/mithril/advanced/mithril-protocol/certificates/) for more details about Mithril's certificate chain, which is what we are replicating in this process.

We will have exactly one NFT asset representing the stake distribution. Since the first certificate processed by the validator is a genesis certificate (as well as in Mithril's certificate chain), there will be a special `stake_distribution_tx` for the first time, which mints an NFT asset given a `MithrilStakeDistribution` genesis certificate, using a minting validator. This NFT asset will be in the same UTxO as the genesis certificate (Mithril certificates are in the datum of each UTxO).

In each other stake distribution transaction, we must process a new `MithrilStakeDistribution` certificate `C` (which will be passed in the redeemer), as we spend an UTxO containing the parent certificate of `C`. The new UTxO generated must recieve the NFT asset representinf the stake distribution. For doing this, the redeemer for this transaction must have a Groth16 Proof for verifying `C`'s multisignature.

## Validators

### Minting validator (`validators/minting.ak`)

The minting validator must verify the following points:

 1. The presented locking transaction has not been used previously.
 2. The locking transaction belongs to the source chain.
 3. The amount of tokens to be minted is the same as the amount locked in the locking transaction.
 4. The destination address of the locking transaction is the one receiving the funds in the minting transaction.

The first point is verified in the auxiliary function `locking_tx_hash_is_added_to_the_used_txs_set`. This function verifies that the minting transaction contains an input with the tx_updater NFT. This is done similarly to milestone 3 for the unlocking transaction; by verifying that the transaction contains an input with that NFT, we ensure that the used tx set is being updated in the transaction. Note that it is not necessary to verify that an output with the NFT exists, since we know that if the input has the NFT, it will have the tx_updater validator as a script, which requires that the output exists to spend it.

Additionally, we validate that the used tx set was updated with the hash presented in the redeemer of the minting transaction, which is the one appearing in the Mithril certificates. This is important because otherwise, someone could update the used tx set with a hash that is not from the locking transaction, allowing the locking transaction to be reused to mint tokens in the bridge, thus generating a double spend.

The second point is validated in the functions `verify_mithril_standard_certificate` and `verify_transaction_is_present_in_snapshot`. In these functions, we verify that the Mithril transaction snapshot certificate is valid (this uses a Mithril stake distribution certificate received as a reference input) and that the hash of the locking transaction is in the Merkle tree contained in that certificate. In this milestone we will use empty circuits to act as placeholders. We will write the real circuits in the next milestone.

Once we are certain that the hash of the locking transaction is in the Merkle tree of the certificate, we need to ensure that the transaction with that hash really has the amount of tokens being minted and that the destination address is the one receiving those tokens (points 3 and 4). We do this in the function `locking_tx_hash_is_correct`. There, we reconstruct the locking transaction from the redeemer data, which includes the tokens to be minted and the destination address, and recompute its hash to verify that it matches the expected value.

### Transactions Updater validator (`validators/tx_updater_minting.ak`)

As we said, this validator was used in the unlocking transaction from the previous milestone. However, there are minimal modifications we had to make for the validator to be adapted to the minting transaction. Most of the code is equal, but the differences make that we separate it into two new validators. This is reasonable, since they are validators that live in different chains: `txs_updater_minting` lives in the destination chain, while `txs_updater_unlocking` lives in the source chain.

In the last milestone transaction updater validator, we had to verify that there is was other input with the unlocking script as it's address. This was to ensure that the burning transaction hash used to update de used transactions set was also used to unlock funds from the bridge. If we didn't do this validation, someone could use a burning transaction hash to update the transactions set and those tokens would be locked forever.

In this milestone we need to do something similar. Since this is a minting transaction, we won't be looking for any input. We need to check that the transaction is minting tokens for the minting script. This means that we will be using a different `tx_id_in_both_redeemers_are_equal` function, which will check that another redeemer in the transaction has a minting `ScriptPurpose` for the minting script's `PolicyId`. We also check that we are effectively minting a positive amount of tokens.

### Stake distribution validator (`validators/stake_distribution.ak`)

We will consider both instances of the stake distribution validator: the minting script for generating the first stake distribution certificate NFT asset (for the genesis certificate), and the spending script for updating the NFT asset with a new `MithrilStakeDistribution` certificate.

For both instances, the `Redeemer` must contain the certificate `C` to process in this transaction. Additionally, for the spending script the `Redeemer` must additionally contain a Groth16 Proof `P` for verifying `C`'s multisignature (in this milestone, `P` is a mock proof).

The minting script validates that:

- `C` is indeed a genesis certificate, by verifying it contains a `GenesisSignature`.
- `C` is a valid Mithril genesis certificate.
- This stake distribution transaction generates an UTxO `O` that contains `C` in its datum.
- `O` contains an NFT asset, which represents the latest `MithrilStakeDistribution` certificate processed by our bridge.

The minting script can be instantiated for a specific UTxO which modifies the `policy_id` of the stake distribution certificate NFT asset. This implies unforgeability of an asset with the same `policy_id`, starting from a different valid genesis certificate. Mithril's generate vertification key is hardcoded in the validator.

The spending script spends an UTxO `O1` validates that:

- `O1` contains a Mithril certificate in its datum, which will be the parent certificate of `C` in the ideal case.
- `C` is effectively a `MithrilStakeDistribution` certificate.
- The stake distribution transaction generates an UTxO `O2` that contains `C` in its datum.
- `C` is a valid Mithril certificate. This implies verifying its multisignature using `P`. For this milestone, every certificate verification step is implemented except for the signature verifications, and `P` is a mock proof.
- `O1` and `O2` have the same spending script. This means that `O2` will be only possible to spend in this spending script.
- The stake distribution transaction moves `O1`'s stake distribution certificate NFT asset to `O2`.

## Technical considerations

### Certificates

Our Aiken implementation follows Mithril's certificate verification in [Mithril Repository](https://github.com/input-output-hk/mithril/). The verification is done by implementing the same functions in Aiken. This allows to correctly verify multiple real Mithril certificates obtained using the Mithril aggregator and manually converted to Aiken types. Our implementation, however, comes with the following differences:

In the `CertificateMetadata` struct, there are parameters `initiated_at` and `sealed_at`, which represent the date and time at which the single signatures registration is opened and the quorum of single signatures was reached and they were aggregated into a multisignature, respectively. In the Rust implementation, their type is `DateTime<Utc>`, which does not have a direct equivalent in Aiken. Since its only use in the certificate verification process is to participate in the construction of the hash as part of the input, we have decided to store those parameters as `ByteArray` in our `MithrilCertificate` implementation, allowing for efficient use of the `append_bytearray` function.

In the `ProtocolParameters` struct, there is a `phi_f` parameter, which is `f` in the formula `phi(w) = 1 - (1 - f)^w`, where `w` is the stake of a participant. In the Rust implementation, its type is `f64`, and moreover the value used during the certificate process is the fixed point representation `U8F24::from_num(self.phi_f)` (none of this has a direct equivalent in Aiken, and using a `Rational` would not work because it is an `opaque` type and we need to pass each certificate in a `Redeemer`). Since this can be computed before verifying the certificate, for our Aiken `MithrilCertificate` we can convert the value previously and just store the parameter as a `ByteArray`.

The `ProtocolMessage` struct just contains a `BTreeMap<ProtocolMessagePartKey, ProtocolMessagePartValue>`, where `ProtocolMessagePartKey` is an enumerable data type containing the possible protocol messages contained in a Mithril certificate, and `ProtocolMessagePartValue` is just a `String`. However, we cannot use a `Dict` since we need to pass each certificate in a `Redeemer`. Our solution is using the Aiken `Pairs<ProtocolMessagePartKey, String>` data type, but with the developer **manually** guaranteeing the ordering of the `ProtocolMessagePartKey` when constructing instances of a `ProtocolMessage`. This means, for example, that:
  
```rust
  [
    Pair(
      NextAggregateVerificationKey,
      @"7b226d745f636f6d6d69746d656e74223a7b22726f6f74223a5b3137332c35312c31382c3231392c3230352c3230372c33302c3136362c3232342c3139392c3138322c3137342c3234342c34392c3138352c34362c38392c3131382c3231322c3233372c32392c33382c3138342c3136372c3232322c312c3133382c3135322c39342c35392c39392c38385d2c226e725f6c6561766573223a31362c22686173686572223a6e756c6c7d2c22746f74616c5f7374616b65223a3137363331323733333831383334357d",
    ),
    Pair(
      NextProtocolParameters,
      @"b01de82ca7e57c1bf2a56381ce265f378aeea5f1dde7f824b5ba42125c4adad2",
    ),
    Pair(
      CurrentEpoch,
      @"1150"
    ),
  ]
```

is a valid `ProtocolMessage`, while.

```rust
  [
    Pair(
      NextAggregateVerificationKey,
      @"7b226d745f636f6d6d69746d656e74223a7b22726f6f74223a5b3137332c35312c31382c3231392c3230352c3230372c33302c3136362c3232342c3139392c3138322c3137342c3234342c34392c3138352c34362c38392c3131382c3231322c3233372c32392c33382c3138342c3136372c3232322c312c3133382c3135322c39342c35392c39392c38385d2c226e725f6c6561766573223a31362c22686173686572223a6e756c6c7d2c22746f74616c5f7374616b65223a3137363331323733333831383334357d",
    ),
    Pair(
      CurrentEpoch,
      @"1150"
    ),
    Pair(
      NextProtocolParameters,
      @"b01de82ca7e57c1bf2a56381ce265f378aeea5f1dde7f824b5ba42125c4adad2",
    ),
  ]
```

is an invalid `ProtocolMessage`, even if our implementation does not say so. Another possibility is to add a `is_valid_protocol_message(p: ProtocolMessage) -> Bool` function, but this would add overhead to the process, and it is unnecessary since the validation would already fail when hashing the certificate.

Mithril hashes its different entities using `sha2_256`. During the `MithrilCertificate`'s hashing process, we need to hash its `CertificateMetadata`, and for hashing that we need to hash its `ProtocolParameters`. This goes on for some more parameters. However, Mithril's implementation introduces an unnecessary additional overhead to this process during each `compute_hash()` function: since it converts them to `String` using the `hex::encode()` function, later when it appends its bytes to hash the next structure, it will append twice the number of bytes. This adds overhead to the certificate hashing process.

- For example, if some `sha2_256` digest is `ace019657cd995b0dfbb1ce8721a1092715972c4ae0171cc636ab4a44e6e4279`, the corresponding string that Mithril's implementation appends to the input of the next hash function is `61636530313936353763643939356230646662623163653837323161313039323731353937326334616530313731636336333661623461343465366534323739`.

Therefore, we need to solve the problem of converting a `ByteArray` digest in Aiken, to the other `ByteArray`. Aiken provides both `bytearray.to_hex` and `string.to_bytearray` as functions, and its composition should work. However, the Aiken transformation gives uppercase `A-F` hex digits, while the `hex` crate in Rust gives lowercase `a-f` hex digits. We solve this issue by implementing a particular `digest_to_bytes_of_string` low-level function, but of course it still adds overhead.

This problem does not only appear for parameters that are hashed, but also for other parameters in the `MithrilCertificate` (since they are represented as `String` in Rust). The most relevant case is that it happens for the multisignature, which can be of several kilobytes (for example, instead of appending and hashing 4KB, it would be 8KB). We plan to communicate with Mithril so that they review their Rust implementation, while we understand that our proposal implies breaking changes. Solving this will tremendously decrease the `MithrilCertificate` size of our Aiken struct, and reducing the execution units for both the minting validator and the stake distribution validator.

The signature verification in both cases, genesis signature and multisignature, can be done with ZK circuits. This will be implemented in the next milestone, but there are mock functions for this implementation.

Because of the additional overhead of hashing certificates in Aiken, it is probable that for the next milestone we add a ZK circuit in Circom for hashing a certificate, and only verificate the corresponding proof in Aiken. We will provide the corresponding benchmark of this approach.

### Validators compilation order

Note that the process requires that the files are compiled in a certain order. We have the following compilation dependencies:

- → `sd_mint`, `txs_updater_mint`
- `sd_mint` → `sd_spend`
- `sd_mint`, `txs_updater_mint` → `minting`
- `tx_updater_mint`, `minting` → `txs_updater_spend`

- First, we can compile `sd_mint` and `txs_updater_mint`
- Second, we can compile `sd_spend` and `minting`.
- Third, we can compile `txs_updater_spend`.

After each compilation, the corresponding hash should be copied and pasted in the corresponding variable in the env file.

### Solving a bug from the previous milestone

During testing, we found out that there was a bug with the `unlocking_validator` we submitted for the previous milestone. We needed to determine, between all the outputs of the unlocking transaction which was the output for the unlocked funds. For this purpose, we passed a destination address in the `Redeemer`, and looked for an UTxO generated in this transaction that was for this destination address:

```rust
fn find_output_of_address(address: Address, tx: Transaction) -> Option<Output> {
  list.find(
    tx.outputs,
    fn(o) { o.address.payment_credential == address.payment_credential },
  )
}
```

However, this was a sub-especification. It is possible to construct a transaction that should pass the unlocking script, but fails. Suppose that `A` constructs an unlocking transaction, where the unlocked funds are for himself: this means that he puts his address as the destination address in the `Redeemer`. The transaction has, between others, the following inputs and outputs in this order (we are using the tx3 DSL to describe these inputs/outputs):

```tx3
input source {
  from: A,
  min_amount: one_ada + fees,
}

output change {
  to: A,
  amount: source - (one_ada + fees),
}

output unlocked_funds {
  to: A,
  amount: one_ada + unlock_value,
}
```

Since `list.find` finds the first output between the ordered list `tx.outputs` whose address is `A`'s address, it will find the `change` output for the unlocking transaction instead of the `unlocked_funds` output. The validator then must do other validations about this output, which will fail since it is a different output. It is clear that reversing the order of outputs in the transaction would solve the issue, but that should not be necessary for users of the bridge. In this deliverable, our updated unlocking validator searches both for the address and the expected value of the output.

## Testing

There are Aiken tests for the stake distribution validator and the minting validator are in [this file](validators/tests/stake_distribution_test.ak) and [this file](validators/tests/minting_test.ak) respectively. Their names are mostly self-explanatory.

To run the tests, just [install Aiken](https://aiken-lang.org/installation-instructions) and use the command:

```bash
cd zk-bridge
aiken check
```

The new tests are:

### validators/tests/tx_updater_test.ak

 - `txs_updater_for_minting_tx`
 - `txs_updater_for_minting_tx_must_be_minting_transferred_tokens`

### validators/tests/minting_test
 - `minting_validator_test`
 - `minting_validator_test_with_many_inputs`
 - `minting_validator_test_with_many_outputs`
 - `minting_validator_test_with_many_reference_inputs`
 - `minting_validator_invalid_mithril_proof_test`
 - `minting_validator_invalid_merkle_proof_test`
 - `minting_validator_test_incorrect_locking_tx_hash`
 - `minting_validator_checks_that_one_input_has_tx_updater_nft`

 ### validators/tests/hash_certificate.ak
 - `sha2_256_test`
 - `sha3_256_test`
 - `hash_certificate_test`
 - `hash_genesis_certificate_test`
 - `hash_real_genesis_certificate_test`
 - `hash_real_sd_certificate_test`
 - `hash_real_cardano_transactions_certificate_test`
 - `hash_parent_of_real_cardano_transactions_certificate_test`
 - `hash_certificate_metadata_test`
 - `hash_protocol_parameters_test`
 - `hash_protocol_message_test`
 - `hash_protocol_message_2_test`

 ### validators/tests/stake_distribution_test.ak
 - `stake_distribution_validator_genesis_certificate_test`
 - `stake_distribution_validator_genesis_certificate_without_parent_certificate_test`
 - `stake_distribution_validator_genesis_certificate_with_a_different_utxo_test`
 - `stake_distribution_validator_sd_certificate_test`
 - `stake_distribution_validator_invalid_mithril_proof_test`
 - `stake_distribution_validator_sd_certificate_must_have_parent_certificate_test`
 - `stake_distribution_validator_new_certificate_must_have_same_spending_script_test`
 - `stake_distribution_validator_incorrect_parent_certificate_hash_test`
 - `stake_distribution_validator_sd_certificate_has_not_one_epoch_more_than_parent_certificate_test`
 - `stake_distribution_validator_sd_certificate_with_incorrect_aggregate_verification_key_test`
 - `stake_distribution_validator_sd_certificate_with_incorrect_protocol_parameters_test`
 - `stake_distribution_validator_with_incorrect_signed_entity_type_test`